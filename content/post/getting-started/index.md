---
title: Paging **
subtitle: oooooooooooonew site with some initial content to help you get
  familiar with everything in no time.
date: 2020-12-13T00:00:00.000Z
summary: Welcome ðŸ‘‹ We know that first impressions are important, so we've
  populated your new site with some initial content to help you get familiar
  with everything in no time.
draft: false
featured: false
authors:
  - admin
  - ""
lastmod: 2020-12-13T00:00:00.000Z
tags:
  - Tech
categories:
  - System Design
projects: []
image:
  caption: "Image credit: [**Unsplash**](https://unsplash.com/photos/CpkOjOcXdUY)"
  focal_point: ""
  placement: 2
  preview_only: false
---
We break physical memory into fixed-sized blocks calledÂ **frames**Â and break logical memory into blocks of the same size calledÂ **pages**. When a process is to be executed, its pages are loaded into any available memory frames from their source (a file system or the backing store). The backing store is divided into fixed-sized blocks that are the same size as the memory frames or clusters of multiple frames.

For example, the logical address space is now totally separate from the physical address space

![](https://miro.medium.com/max/1400/1*FbwqGKF4uS6ErW_NiYCHug.jpeg)

Every address generated by the CPU is divided into two parts: aÂ **page number (p)**Â and aÂ **page offset (d)**. The page number is used as an index into aÂ **page table**. The page table contains the base address of each page in physical memory. This base address is combined with the page offset to define the physical memory address that is sent to the memory unit. Since main memory is much faster than secondary memory , it saves us a lot of time

*Paging hardware with TLB.*

![](https://miro.medium.com/max/1400/1*Q3ptmeooys_HhkclCbd-RQ.jpeg)

it will very ineffucient for us to calcute through page table as 1 page contain lot of instruction (more than 100 instruction . We use TLB

*Protection*Â â€”

![](https://miro.medium.com/max/1400/1*hkBS3U66PYGyCXb5uTRGBQ.jpeg)

We can create hardware to provide read-only, readâ€“write, or execute-only protection; or, by providing separate protection bits for each kind of access, we can allow any combination of these accesses. Illegal attempts will be trapped to the operating system.

One additional bit is generally attached to each entry in the page table: aÂ **validâ€“invalid**Â bit. When this bit is set toÂ *valid,*Â the associated page is in the processâ€™s logical address space and is thus a legal (or valid) page. When the bit is set to*invalid,*Â the page is not in the processâ€™s logical address space. Illegal addresses are trapped by use of the validâ€“invalid bit. The operating system sets this bit for each page to allow or disallow access to the page.

Shared Pages â€”

![](https://miro.medium.com/max/1400/1*mqbOXTHm_tHfI5qg3IYrOA.jpeg)

An advantage of paging is the possibility ofÂ ***sharing***Â common code. This con- sideration is particularly important in a time-sharing environment. Consider a system that supports 40 users, each of whom executes a text editor. If the text editor consists of 150 KB of code and 50 KB of data space, we need 8,000 KB to support the 40 users. If the code isÂ **reentrant code**Â (orÂ **pure code**), however, it can be shared, as shown in figure below

Only one copy of the editor need be kept in physical memory. Each userâ€™s page table maps onto the same physical copy of the editor, but data pages are mapped onto different frames. Thus, to support 40 users, we need only one copy of the editor (150 KB), plus 40 copies of the 50 KB of data space per user. The total space required is now 2,150 KB instead of 8,000 KB â€” a significant savings.

Other heavily used programs can also be shared â€” compilers, window systems, run-time libraries, database systems, and so on. To be sharable, the code must be reentrant. The read-only nature of shared code should not be left to the correctness of the code; the operating system should enforce this property.