---
title: Paging **
subtitle: ""
date: 2020-12-13T00:00:00.000Z
summary: >-
  This is part of series on networking for system design


  Caution — aim of these series is not to make you networking expert. this is just prepare you for system design
draft: false
featured: false
authors:
  - admin
  - ""
lastmod: 2020-12-13T00:00:00.000Z
tags:
  - Tech
categories:
  - System Design
projects: []
image:
  caption: "Image credit: [**Unsplash**](https://unsplash.com/photos/CpkOjOcXdUY)"
  focal_point: ""
  placement: 2
  preview_only: false
---
We break physical memory into fixed-sized blocks called **frames** and break logical memory into blocks of the same size called **pages**. When a process is to be executed, its pages are loaded into any available memory frames from their source (a file system or the backing store). The backing store is divided into fixed-sized blocks that are the same size as the memory frames or clusters of multiple frames.

For example, the logical address space is now totally separate from the physical address space

![](https://miro.medium.com/max/1400/1*FbwqGKF4uS6ErW_NiYCHug.jpeg)

Every address generated by the CPU is divided into two parts: a **page number (p)** and a **page offset (d)**. The page number is used as an index into a **page table**. The page table contains the base address of each page in physical memory. This base address is combined with the page offset to define the physical memory address that is sent to the memory unit. Since main memory is much faster than secondary memory , it saves us a lot of time

*Paging hardware with TLB.*

![](https://miro.medium.com/max/1400/1*Q3ptmeooys_HhkclCbd-RQ.jpeg)

it will very ineffucient for us to calcute through page table as 1 page contain lot of instruction (more than 100 instruction . We use TLB

*Protection* —

![](https://miro.medium.com/max/1400/1*hkBS3U66PYGyCXb5uTRGBQ.jpeg)

We can create hardware to provide read-only, read–write, or execute-only protection; or, by providing separate protection bits for each kind of access, we can allow any combination of these accesses. Illegal attempts will be trapped to the operating system.

One additional bit is generally attached to each entry in the page table: a **valid–invalid** bit. When this bit is set to *valid,* the associated page is in the process’s logical address space and is thus a legal (or valid) page. When the bit is set to*invalid,* the page is not in the process’s logical address space. Illegal addresses are trapped by use of the valid–invalid bit. The operating system sets this bit for each page to allow or disallow access to the page.

Shared Pages —

![](https://miro.medium.com/max/1400/1*mqbOXTHm_tHfI5qg3IYrOA.jpeg)

An advantage of paging is the possibility of ***sharing*** common code. This con- sideration is particularly important in a time-sharing environment. Consider a system that supports 40 users, each of whom executes a text editor. If the text editor consists of 150 KB of code and 50 KB of data space, we need 8,000 KB to support the 40 users. If the code is **reentrant code** (or **pure code**), however, it can be shared, as shown in figure below

Only one copy of the editor need be kept in physical memory. Each user’s page table maps onto the same physical copy of the editor, but data pages are mapped onto different frames. Thus, to support 40 users, we need only one copy of the editor (150 KB), plus 40 copies of the 50 KB of data space per user. The total space required is now 2,150 KB instead of 8,000 KB — a significant savings.

Other heavily used programs can also be shared — compilers, window systems, run-time libraries, database systems, and so on. To be sharable, the code must be reentrant. The read-only nature of shared code should not be left to the correctness of the code; the operating system should enforce this property.